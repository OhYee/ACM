---
title: (转)巧妙运用C语言位运算+位运算笔记
categories: 
 - 笔记
tags:
  - 位运算
date: 2016-03-26 00:41:00
---
# 位运算
> 位运算的运算分量只能是整型或字符型数据，位运算把运算对象看作是由二进位组成的位串信息，按位完成指定的运算，得到位串信息的结果。 
位运算符有： 
> &(按位与)、|(按位或)、^(按位异或)、~ (按位取反)。  
>  
> 其中，按位取反运算符是单目运算符，其余均为双目运算符。  
>  
> 位运算符的优先级从高到低，依次为~、&、^、|，  
>  
> 其中~的结合方向自右至左，且优先级高于算术运算符，其余运算符的结合方向都是自左至右，且优先级低于关系运算符。  
>  

## (1)按位与运算符(&) 
按位与运算将两个运算分量的对应位按位遵照以下规则进行计算：   
     `0 & 0 = 0, 0 & 1 = 0, 1 & 0 = 0, 1 & 1 = 1`。   
即同为 1 的位，结果为 1，否则结果为 0。   
例如，设3的内部表示为   
 00000011   
5的内部表示为   
 00000101   
则3&5的结果为   
 00000001   
按位与运算有两种典型用法，一是取一个位串信息的某几位，如以下代码截取x的最低7位：x & 0177。二是让某变量保留某几位，其余位置0，如以下代码让x只保留最低6位：x = x & 077。以上用法都先要设计好一个常数，该常数只有需要的位是1，不需要的位是0。用它与指定的位串信息按位与。   
  

## (2)按位或运算符(|)
按位或运算将两个运算分量的对应位按位遵照以下规则进行计算： 
  
`0 | 0 = 0, 0 | 1 = 1, 1 | 0 = 1, 1 | 1 = 1` 
     
即只要有1个是1的位，结果为1，否则为0。   

例如，023 | 035 结果为037。   

按位或运算的典型用法是将一个位串信息的某几位置成1。如将要获得最右4为1，其他位与变量j的其他位相同，可用逻辑或运算017|j。若要把这结果赋给变量j，可写成： 
     j = 017|j 


## (3)按位异或运算符(^) 
按位异或运算将两个运算分量的对应位按位遵照以下规则进行计算：  
 
     `0 ^ 0 = 0, 0 ^ 1 = 1, 1 ^ 0 = 1, 1 ^ 1 = 0 `
     
即相应位的值相同的，结果为 0，不相同的结果为 1。   

例如，013^035结果为026。 

异或运算的意思是求两个运算分量相应位值是否相异，相异的为1，相同的为0。按位异或运算的典型用法是求一个位串信息的某几位信息的反。如欲求整型变量j 的最右4位信息的反，用逻辑异或运算017^j，就能求得j最右4位的信息的反,即原来为1的位，结果是0,原来为0的位，结果是1。   


## (4)按位取反运算符(~)  
按位取反运算是单目运算，用来求一个位串信息按位的反，即哪些为0的位，结果是1，而哪些为1的位，结果是0。例如, ~7的结果为0xfff8。  
 
取反运算常用来生成与系统实现无关的常数。如要将变量x最低6位置成0，其余位不变，可用代码x = x & ~077实现。以上代码与整数x用2个字节还是用4个字节实现无关。  
 
当两个长度不同的数据进行位运算时(例如long型数据与int型数据)，将两个运算分量的右端对齐进行位运算。如果短的数为正数，高位用0补满；如果短的数为负数，高位用1补满。如果短的为无符号整数，则高位总是用0补满。  
 
位运算用来对位串信息进行运算，得到位串信息结果。如以下代码能取下整型变量k的位串信息的最右边为1的信息位：((k-1)^k) & k。  
 


## 移位运算 
移位运算用来将整型或字符型数据作为二进位信息串作整体移动。有两个运算符：   
### &lt;&lt; (左移) 和 >> (右移)    
移位运算是双目运算，有两个运算分量,左分量为移位数据对象，右分量的值为移位位数。移位运算将左运算分量视作由二进位组成的位串信息,对其作向左或向右移位，得到新的位串信息。   

移位运算符的优先级低于算术运算符，高于关系运算符，它们的结合方向是自左至右。   

### (1)左移运算符(&lt;&lt;)   

左移运算将一个位串信息向左移指定的位，右端空出的位用0补充。例如014&lt;&lt;2,结果为060,即48。   

左移时，空出的右端用0补充，左端移出的位的信息就被丢弃。在二进制数运算中，在信息没有因移动而丢失的情况下，每左移1位相当于乘2。如4 &lt;&lt; 2，结果为16。   

### (2)右移运算符(>>)   

右移运算将一个位串信息向右移指定的位，右端移出的位的信息被丢弃。例如12>>2,结果为3。与左移相反，对于小整数，每右移1位，相当于除以2。在右移时，需要注意符号位问题。对无符号数据，右移时，左端空出的位用0补充。对于带符号的数据，如果移位前符号位为0(正数)，则左端也是用0   

补充；如果移位前符号位为1(负数)，则左端用0或用1补充，取决于计算机系统。对于负数右移，称用0 补充的系统为“逻辑右移”，用1补充的系统为“算术右移”。以下代码能说明读者上机的系统所采用的右移方法：   

`printf("%d\n\n\n", -2>>4);`  

若输出结果为-1，是采用算术右移；输出结果为一个大整数，则为逻辑右移。   

移位运算与位运算结合能实现许多与位串运算有关的复杂计算。设变量的位自右至左顺序编号，自0位至15位，有关指定位的表达式是不超过15的正整数。以下各代码分别有它们右边注释所示的意义：   

```cpp
~（~0 << n） /* 实现最低n位为1，其余位为0的位串信息 */   

(x >> (1+p-n)) & ~(~0 << n) /* 截取变量x自p位开始的右边n位的信息 */   

new |= ((old >> row) & 1) << (15 – k) /* 截取old变量第row位，并将该位信息装配到变量new的第15-k位 */   

s &= ~(1 << j) /* 将变量s的第j位置成0，其余位不变 */   

for(j = 0; ((1 << j) & s) == 0; j++) ; /* 设s不等于全0，代码寻找最右边为1的位的序号j */  
```
  
  
！为逻辑取反，表示非的意思  

经过它处理后的结果为布尔型，要么为0，要么为1，!x，只要x不为0，1,2，3，都可以，那么!x的结果就是0，只有当x为0时，结果为1。如果*为真，则！*为假，反之如果*为假，则！*为真  
  
   

 # 其他

## lowbit函数
```cpp
int lowbit(int x){
    return x&(-x);    
} 
```
由于程序数据用补码保存，负数是其绝对值取反+1  
`1（0001）`  
`-1（1111）`  
`1&（-1）=0001`  

其意义是将只保留最低位的1  
换成10进制后就是2i（i是最低位的1的位数）



## 判断最后一位
`x&1;` 可以取得x最后一位是1还是0

## +1
将一个数+1，可以将其最后一个0变成1，比其低的位变成0

## -1
将一个数-1，可以将其最后一个1变成0，比其低的位变成1

## 计算二进制中1的个数
```cpp
int bitCount(int i) {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    i = (i + (i >>> 4)) & 0x0f0f0f0f;
    i = i + (i >>> 8);
    i = i + (i >>> 16);
    return i & 0x3f;
}
```


## 返回右起第一个1的位置
Returns one plus the index of the least significant 1-bit of x, or if x is zero, returns zero.
```cpp
int __builtin_ffs (unsigned int x)
int __builtin_ffsl (unsigned long)
int __builtin_ffsll (unsigned long long)
```

## 返回左起第一个1之前0的个数
Returns the number of leading 0-bits in x, starting at the most significant bit position. If x is 0, the result is undefined.
```cpp
int __builtin_clz (unsigned int x)
int __builtin_clzl (unsigned long)
int __builtin_clzll (unsigned long long)
```


## 返回右起第一个1之后的0的个数
Returns the number of trailing 0-bits in x, starting at the least significant bit position. If x is 0, the result is undefined.
```cpp
int __builtin_ctz (unsigned int x)
int __builtin_ctzl (unsigned long)
int __builtin_ctzll (unsigned long long)
```


## 返回1的个数
Returns the number of 1-bits in x.
```cpp
int __builtin_popcount (unsigned int x)
int __builtin_popcountl (unsigned long)
int __builtin_popcountll (unsigned long long)
```

## 返回1的个数的奇偶性
Returns the parity of x, i.e. the number of 1-bits in x modulo 2.
```cpp
int __builtin_parity (unsigned int x)
int __builtin_parityl (unsigned long)
int __builtin_parityll (unsigned long long)
```